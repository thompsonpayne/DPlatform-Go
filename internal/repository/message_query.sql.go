// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: message_query.sql

package repository

import (
	"context"
	"database/sql"
)

const createMessage = `-- name: CreateMessage :one
insert into messages (id, room_id, user_id, content)
values (?, ?, ?, ?)
returning id, room_id, user_id, content, created_at
`

type CreateMessageParams struct {
	ID      string
	RoomID  string
	UserID  string
	Content string
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRowContext(ctx, createMessage,
		arg.ID,
		arg.RoomID,
		arg.UserID,
		arg.Content,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.RoomID,
		&i.UserID,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}

const deleteMessage = `-- name: DeleteMessage :exec
;

delete from messages where id = ?
`

func (q *Queries) DeleteMessage(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteMessage, id)
	return err
}

const getInitalMessages = `-- name: GetInitalMessages :many
select message_id, content, created_at, user_id, user_name, user_email, room_id, room_name from
    (
        select
            messages.id as message_id,
            messages.content, messages.created_at,
            users.id as user_id,
            users.name as user_name,
            users.email as user_email,
            rooms.id as room_id,
            rooms.name as room_name
        from messages
        join users on messages.user_id = users.id
        join rooms on messages.room_id = rooms.id
        where room_id = ?
        order by messages.created_at desc
        limit 10)
        sub
order by sub.created_at asc
`

type GetInitalMessagesRow struct {
	MessageID string
	Content   string
	CreatedAt sql.NullTime
	UserID    string
	UserName  string
	UserEmail string
	RoomID    string
	RoomName  string
}

func (q *Queries) GetInitalMessages(ctx context.Context, roomID string) ([]GetInitalMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getInitalMessages, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInitalMessagesRow
	for rows.Next() {
		var i GetInitalMessagesRow
		if err := rows.Scan(
			&i.MessageID,
			&i.Content,
			&i.CreatedAt,
			&i.UserID,
			&i.UserName,
			&i.UserEmail,
			&i.RoomID,
			&i.RoomName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaginatedMessages = `-- name: GetPaginatedMessages :many
select message_id, content, created_at, user_id, user_name, user_email, room_id, room_name from
    (select
        messages.id as message_id,
        messages.content, messages.created_at,
        users.id as user_id, users.name as user_name, users.email as user_email,
        rooms.id as room_id,
        rooms.name as room_name
    from messages
    join users on messages.user_id = users.id
    join rooms on messages.room_id = rooms.id
    where room_id = ? and datetime (messages.created_at) < datetime (?)
    order by messages.created_at desc
    limit 10) sub
order by sub.created_at asc
`

type GetPaginatedMessagesParams struct {
	RoomID   string
	Datetime interface{}
}

type GetPaginatedMessagesRow struct {
	MessageID string
	Content   string
	CreatedAt sql.NullTime
	UserID    string
	UserName  string
	UserEmail string
	RoomID    string
	RoomName  string
}

func (q *Queries) GetPaginatedMessages(ctx context.Context, arg GetPaginatedMessagesParams) ([]GetPaginatedMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getPaginatedMessages, arg.RoomID, arg.Datetime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPaginatedMessagesRow
	for rows.Next() {
		var i GetPaginatedMessagesRow
		if err := rows.Scan(
			&i.MessageID,
			&i.Content,
			&i.CreatedAt,
			&i.UserID,
			&i.UserName,
			&i.UserEmail,
			&i.RoomID,
			&i.RoomName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMessage = `-- name: UpdateMessage :exec
;

update messages
set content = ?
where id = ?
`

type UpdateMessageParams struct {
	Content string
	ID      string
}

func (q *Queries) UpdateMessage(ctx context.Context, arg UpdateMessageParams) error {
	_, err := q.db.ExecContext(ctx, updateMessage, arg.Content, arg.ID)
	return err
}
